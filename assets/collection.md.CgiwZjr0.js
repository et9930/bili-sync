import{_ as e,c as a,o,a3 as t}from"./chunks/framework.Bsyxd66g.js";const s="/assets/collection.eQK09b-S.webp",i="/assets/season.BN7DfX7D.webp",c="/assets/series.BJFpEKxT.webp",k=JSON.parse('{"title":"获取视频合集/视频列表信息","description":"","frontmatter":{},"headers":[],"relativePath":"collection.md","filePath":"collection.md","lastUpdated":1723132976000}'),r={name:"collection.md"},l=t('<h1 id="获取视频合集-视频列表信息" tabindex="-1">获取视频合集/视频列表信息 <a class="header-anchor" href="#获取视频合集-视频列表信息" aria-label="Permalink to &quot;获取视频合集/视频列表信息&quot;">​</a></h1><p>要说明的是，视频合集和视频列表虽然在哔哩哔哩网站交互上行为类似，但在接口层级是两个不同的概念。可以简单将视频列表理解为一个老旧版本的视频合集。</p><p>在调试过程中我注意到视频列表的 ID 可以通过某种规则转换为视频合集的 ID，从而成功调用视频合集的接口，但由于不清楚具体的转换策略，在 bili-sync 的实现中还是将其当成两种类型处理。</p><h2 id="区分方法" tabindex="-1">区分方法 <a class="header-anchor" href="#区分方法" aria-label="Permalink to &quot;区分方法&quot;">​</a></h2><p>这两种类型可以很容易地通过如下手段区分：</p><ol><li>两者的名称前缀不同，视频合集会有显式的“合集”字样</li><li>两者的图标不同</li></ol><p>如下图所示，“合集【命运方舟全剧情解说】”是视频合集，而“阿拉德冒险记”是视频列表。 <img src="'+s+'" alt="image"></p><p>在 bili-sync 的设计中，视频合集的 key 为 <code>season:{mid}:{season_id}</code>，而视频列表的 key 为 <code>series:{mid}:{series_id}</code>。</p><h2 id="参数获取" tabindex="-1">参数获取 <a class="header-anchor" href="#参数获取" aria-label="Permalink to &quot;参数获取&quot;">​</a></h2><p>了解了区分方法后，我们可以通过如下步骤获取视频合集/视频列表的信息。</p><h3 id="视频合集" tabindex="-1">视频合集 <a class="header-anchor" href="#视频合集" aria-label="Permalink to &quot;视频合集&quot;">​</a></h3><p><img src="'+i+'" alt="image"></p><p>该视频合集的 key 为 <code>season:521722088:1987140</code>。</p><h3 id="视频列表" tabindex="-1">视频列表 <a class="header-anchor" href="#视频列表" aria-label="Permalink to &quot;视频列表&quot;">​</a></h3><p><img src="'+c+'" alt="image"></p><p>该视频列表的 key 为 <code>series:521722088:387214</code>。</p>',16),n=[l];function d(p,_,h,m,b,u){return o(),a("div",null,n)}const q=e(r,[["render",d]]);export{k as __pageData,q as default};
